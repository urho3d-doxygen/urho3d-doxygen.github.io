<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urho3D: Materials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Urho3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Materials </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="el" href="class_urho3_d_1_1_material.html" title="Describes how to render 3D geometries.">Material</a> and <a class="el" href="class_urho3_d_1_1_technique.html" title="Material technique. Consists of several passes.">Technique</a> resources define how to render 3D scene geometry. On the disk, they are XML or JSON data. Default and example materials exist in the bin/CoreData/Materials &amp; bin/Data/Materials subdirectories, and techniques exist in the bin/CoreData/Techniques subdirectory.</p>
<p >A material defines the textures, shader parameters and culling &amp; fill mode to use, and refers to one or several techniques. A technique defines the actual rendering passes, the shaders to use in each, and all other rendering states such as depth test, depth write, and blending.</p>
<p >A material definition looks like this:</p>
<div class="fragment"><div class="line">&lt;material&gt;</div>
<div class="line">    &lt;technique name=<span class="stringliteral">&quot;TechniqueName&quot;</span> quality=<span class="stringliteral">&quot;q&quot;</span> loddistance=<span class="stringliteral">&quot;d&quot;</span> /&gt;</div>
<div class="line">    &lt;texture unit=<span class="stringliteral">&quot;diffuse|normal|specular|emissive|environment&quot;</span> name=<span class="stringliteral">&quot;TextureName&quot;</span> /&gt;</div>
<div class="line">    &lt;texture ... /&gt;</div>
<div class="line">    &lt;shader vsdefines=<span class="stringliteral">&quot;DEFINE1 DEFINE2&quot;</span> psdefines=<span class="stringliteral">&quot;DEFINE3 DEFINE4&quot;</span> /&gt;</div>
<div class="line">    &lt;parameter name=<span class="stringliteral">&quot;name&quot;</span> value=<span class="stringliteral">&quot;x y z w&quot;</span> /&gt;</div>
<div class="line">    &lt;parameter ... /&gt;</div>
<div class="line">    &lt;cull value=<span class="stringliteral">&quot;cw|ccw|none&quot;</span> /&gt;</div>
<div class="line">    &lt;shadowcull value=<span class="stringliteral">&quot;cw|ccw|none&quot;</span> /&gt;</div>
<div class="line">    &lt;fill value=<span class="stringliteral">&quot;solid|wireframe|point&quot;</span> /&gt;</div>
<div class="line">    &lt;depthbias constant=<span class="stringliteral">&quot;x&quot;</span> slopescaled=<span class="stringliteral">&quot;y&quot;</span> /&gt;</div>
<div class="line">    &lt;alphatocoverage enable=<span class="stringliteral">&quot;true|false&quot;</span> /&gt;</div>
<div class="line">    &lt;lineantialias enable=<span class="stringliteral">&quot;true|false&quot;</span> /&gt;</div>
<div class="line">    &lt;renderorder value=<span class="stringliteral">&quot;x&quot;</span> /&gt;</div>
<div class="line">    &lt;occlusion enable=<span class="stringliteral">&quot;true|false&quot;</span> /&gt;</div>
<div class="line">&lt;/material&gt;</div>
</div><!-- fragment --><p >Several techniques can be defined for different quality levels and LOD distances. Technique quality levels are specified from 0 (low) to 2 (high). When rendering, the highest available technique that does not exceed the <a class="el" href="class_urho3_d_1_1_renderer.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a>'s material quality setting will be chosen, see <a class="el" href="class_urho3_d_1_1_renderer.html#af1a1e53c1d464fe4daf510d2454522f6">SetMaterialQuality()</a>.</p>
<p >The techniques for different LOD levels and quality settings must appear in a specific order:</p>
<ul>
<li>Most distant &amp; highest quality</li>
<li>...</li>
<li>Most distant &amp; lowest quality</li>
<li>Second most distant &amp; highest quality</li>
<li>...</li>
</ul>
<p >Material shader parameters can be floats or vectors up to 4 components, or matrices.</p>
<p >Default culling mode is counterclockwise. The shadowcull element specifies the culling mode to use in the shadow pass. Note that material's depth bias settings do not apply in the shadow pass; during shadow rendering the light's depth bias is used instead.</p>
<p >Render order is a 8-bit unsigned value that can be used to affect rendering order within a pass, overriding state or distance sorting. The default value is 128; smaller values will render earlier, and larger values later. One example use of render order is to ensure that materials which use discard in pixel shader (ALPHAMASK define) are rendered after full opaques to ensure the hardware depth buffer will behave optimally; in this case the render order should be increased. Read below for caveats regarding it.</p>
<p >Occlusion flag allows to disable software occlusion rendering per material, for example if parts of a model are transparent. By default occlusion is enabled.</p>
<p >Materials can optionally set shader compilation defines (vsdefines &amp; psdefines). In this case they will be added to the techniques' own compilation defines, and the techniques are cloned as necessary to ensure uniqueness.</p>
<p >Enabling alpha-to-coverage on the material enables it on all passes. Alternatively it can be enabled per-pass in the technique for fine-grained control.</p>
<h1><a class="anchor" id="Materials_Textures"></a>
Material textures</h1>
<p >Diffuse maps specify the surface color in the RGB channels. Optionally they can use the alpha channel for blending and alpha testing. They should preferably be compressed to DXT1 (no alpha or 1-bit alpha) or DXT5 (smooth alpha) format.</p>
<p >Normal maps encode the tangent-space surface normal for normal mapping. There are two options for storing normals, which require choosing the correct material technique, as the pixel shader is different in each case:</p>
<ul>
<li>Store as RGB. In this case use the DiffNormal techniques. This is the default used by AssetImporter, to ensure no conversion of normal textures needs to happen.</li>
<li>Store as xGxR, ie. Y-component in the green channel, and X-component in the alpha. Z will be reconstructed in the pixel shader. This encoding lends itself well to DXT5 compression. You need to use the pixel shader define PACKEDNORMAL in your materials; refer to the Stone example materials. To convert normal maps to this format, you can use AMD's The Compressonator utility, see <a href="https://developer.amd.com/Resources/archive/ArchivedTools/gpu/compressonator/Pages/default.aspx">https://developer.amd.com/Resources/archive/ArchivedTools/gpu/compressonator/Pages/default.aspx</a>.</li>
</ul>
<p >Make sure the normal map is oriented correctly: an even surface should have the color value R 0.5 G 0.5 B 1.0.</p>
<p >Models using a normal-mapped material need to have tangent vectors in their vertex data; the easiest way to ensure this is to use the switch -t (generate tangents) when using either AssetImporter or OgreImporter to import models to Urho3D format. If there are no tangents, the light attenuation on the normal-mapped material will behave in a completely erratic fashion.</p>
<p >Specular maps encode the specular surface color as RGB. Note that deferred rendering is only able to use monochromatic specular intensity from the G channel, while forward and light pre-pass rendering use fully colored specular. DXT1 format should suit these textures well.</p>
<p >Textures can have an accompanying XML file which specifies load-time parameters, such as addressing, mipmapping, and number of mip levels to skip on each quality level:</p>
<div class="fragment"><div class="line">&lt;texture&gt;</div>
<div class="line">    &lt;address coord=<span class="stringliteral">&quot;u|v|w&quot;</span> mode=<span class="stringliteral">&quot;wrap|mirror|clamp|border&quot;</span> /&gt;</div>
<div class="line">    &lt;border color=<span class="stringliteral">&quot;r g b a&quot;</span> /&gt;</div>
<div class="line">    &lt;filter mode=<span class="stringliteral">&quot;nearest|bilinear|trilinear|anisotropic|nearestanisotropic|default&quot;</span> anisotropy=<span class="stringliteral">&quot;x&quot;</span> /&gt;</div>
<div class="line">    &lt;mipmap enable=<span class="stringliteral">&quot;false|true&quot;</span> /&gt;</div>
<div class="line">    &lt;quality low=<span class="stringliteral">&quot;x&quot;</span> medium=<span class="stringliteral">&quot;y&quot;</span> high=<span class="stringliteral">&quot;z&quot;</span> /&gt;</div>
<div class="line">    &lt;srgb enable=<span class="stringliteral">&quot;false|true&quot;</span> /&gt;</div>
<div class="line">&lt;/texture&gt;</div>
</div><!-- fragment --><p >The sRGB flag controls both whether the texture should be sampled with sRGB to linear conversion, and if used as a rendertarget, pixels should be converted back to sRGB when writing to it. To control whether the backbuffer should use sRGB conversion on write, call <a class="el" href="class_urho3_d_1_1_graphics.html#af80c739184f6f4e7260a282ee4ace9a9">SetSRGB()</a> on the <a class="el" href="class_urho3_d_1_1_graphics.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> subsystem.</p>
<p >Anisotropy level can be optionally specified. If omitted (or if the value 0 is specified), the default from the <a class="el" href="class_urho3_d_1_1_renderer.html" title="High-level rendering subsystem. Manages drawing of 3D views.">Renderer</a> class will be used.</p>
<h1><a class="anchor" id="Materials_CubeMapTextures"></a>
Cube map textures</h1>
<p >Using cube map textures requires an XML file to define the cube map face images, or a single image with layout. In this case the XML file <em>is</em> the texture resource name in material scripts or in LoadResource() calls.</p>
<p >Individual face images are defined in the XML like this: (see bin/Data/Textures/Skybox.xml for an example)</p>
<div class="fragment"><div class="line">&lt;cubemap&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;PositiveX_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;NegativeX_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;PositiveY_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;NegativeY_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;PositiveZ_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;face name=<span class="stringliteral">&quot;NegativeZ_ImageName&quot;</span> /&gt;</div>
<div class="line">&lt;/cubemap&gt;</div>
</div><!-- fragment --><p >Using a single image texture and a layout is used like this:</p>
<div class="fragment"><div class="line">&lt;cubemap&gt;</div>
<div class="line">    &lt;image name=<span class="stringliteral">&quot;ImageName&quot;</span> layout=<span class="stringliteral">&quot;horizontal|horizontalnvidia|horizontalcross|verticalcross|blender&quot;</span> /&gt;</div>
<div class="line">&lt;/cubemap&gt;</div>
</div><!-- fragment --><p >For the layout definitions, see <a href="http://www.cgtextures.com/content.php?action=tutorial&name=cubemaps">http://www.cgtextures.com/content.php?action=tutorial&amp;name=cubemaps</a> and <a href="https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Build_a_skybox">https://en.wikibooks.org/wiki/Blender_3D:_Noob_to_Pro/Build_a_skybox</a></p>
<h1><a class="anchor" id="Materials_3DTextures"></a>
3D textures</h1>
<p >3D textures likewise require an XML file to describe how they should be loaded. The XML should contain either a "volume" or "colorlut" element, which defines the image to load with its "name" attribute. The "volume" mode requires that the image is in a format that supports 3D (volume) textures directly, for example DDS. The "colorlut" mode allows any format, and instead spreads out the Z slices of the volume image horizontally in a 2D image from the left to the right: for example LUTIdentity.png has 16 16x16 slices for a total image size 256x16.</p>
<div class="fragment"><div class="line">&lt;texture3d&gt;</div>
<div class="line">    &lt;colorlut name=<span class="stringliteral">&quot;LUTIdentity.png&quot;</span> /&gt;</div>
<div class="line">&lt;/texture3d&gt;</div>
</div><!-- fragment --><p >Using a 3D texture for color correction postprocess (see bin/Data/PostProcess/ColorCorrection.xml) requires the 3D texture to be assigned to the "volume" texture unit, so that the effect knows to load the texture as the correct type. The lookup for the corrected color happens by using the original color's red channel as the X coordinate, the green channel as the Y coordinate, and blue as the Z. Therefore the identity LUT's slices (which shouldn't transform the color at all) grow red from left to right and green from top to bottom, and finally the slices themselves turn blue from left to right.</p>
<h1><a class="anchor" id="Materials_2DArrayTextures"></a>
2D array textures</h1>
<p >2D array textures (<a class="el" href="class_urho3_d_1_1_texture2_d_array.html" title="2D texture array resource.">Texture2DArray</a> class) are available on OpenGL and Direct3D 11. They are also defined via an XML file defining the images to use on each array layer:</p>
<div class="fragment"><div class="line">&lt;texturearray&gt;</div>
<div class="line">    &lt;layer name=<span class="stringliteral">&quot;Layer1_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;layer name=<span class="stringliteral">&quot;Layer2_ImageName&quot;</span> /&gt;</div>
<div class="line">    &lt;layer name=<span class="stringliteral">&quot;Layer3_ImageName&quot;</span> /&gt;</div>
<div class="line">&lt;/texturearray&gt;</div>
</div><!-- fragment --><h1><a class="anchor" id="Materials_Techniques"></a>
Techniques and passes</h1>
<p >A technique definition looks like this:</p>
<div class="fragment"><div class="line">&lt;technique vs=<span class="stringliteral">&quot;VertexShaderName&quot;</span> ps=<span class="stringliteral">&quot;PixelShaderName&quot;</span> vsdefines=<span class="stringliteral">&quot;DEFINE1 DEFINE2&quot;</span> psdefines=<span class="stringliteral">&quot;DEFINE3 DEFINE4&quot;</span> desktop=<span class="stringliteral">&quot;false|true&quot;</span> &gt;</div>
<div class="line">    &lt;pass name=<span class="stringliteral">&quot;base|litbase|light|alpha|litalpha|postopaque|refract|postalpha|prepass|material|deferred|depth|shadow&quot;</span> desktop=<span class="stringliteral">&quot;false|true&quot;</span> &gt;</div>
<div class="line">        vs=<span class="stringliteral">&quot;VertexShaderName&quot;</span> ps=<span class="stringliteral">&quot;PixelShaderName&quot;</span> vsdefines=<span class="stringliteral">&quot;DEFINE1 DEFINE2&quot;</span> psdefines=<span class="stringliteral">&quot;DEFINE3 DEFINE4&quot;</span></div>
<div class="line">        vsexcludes=<span class="stringliteral">&quot;EXCLUDE1 EXCLUDE2&quot;</span> psexcludes=<span class="stringliteral">&quot;EXCLUDE3 EXCLUDE4&quot;</span></div>
<div class="line">        lighting=<span class="stringliteral">&quot;unlit|pervertex|perpixel&quot;</span></div>
<div class="line">        blend=<span class="stringliteral">&quot;replace|add|multiply|alpha|addalpha|premulalpha|invdestalpha|subtract|subtractalpha&quot;</span></div>
<div class="line">        [cull=<span class="stringliteral">&quot;cw|ccw|none&quot;</span>]</div>
<div class="line">        depthtest=<span class="stringliteral">&quot;always|equal|less|lessequal|greater|greaterequal&quot;</span></div>
<div class="line">        depthwrite=<span class="stringliteral">&quot;true|false&quot;</span></div>
<div class="line">        alphatocoverage=<span class="stringliteral">&quot;true|false&quot;</span> /&gt;</div>
<div class="line">    &lt;pass ... /&gt;</div>
<div class="line">    &lt;pass ... /&gt;</div>
<div class="line">&lt;/technique&gt;</div>
</div><!-- fragment --><p >The "desktop" attribute in either technique or pass allows to specify it requires desktop graphics hardware (exclude mobile devices.) Omitting it is the same as specifying false.</p>
<p >A pass should normally not define culling mode, but it can optionally specify it to override the value in the material.</p>
<p >Shaders are referred to by giving the name of a shader without path and file extension. For example "Basic" or "LitSolid". The engine will add the correct path and file extension (Shaders/HLSL/LitSolid.hlsl for Direct3D, and Shaders/GLSL/LitSolid.glsl for OpenGL) automatically. The same shader source file contains both the vertex and pixel shader. In addition, compilation defines can be specified, which are passed to the shader compiler. For example the define "DIFFMAP" typically enables diffuse mapping in the pixel shader.</p>
<p >Shaders and their compilation defines can be specified on both the technique and pass level. If a pass does not override the default shaders specified on the technique level, it still can specify additional compilation defines to be used. However, if a pass overrides the shaders, then the technique-level defines are not used.</p>
<p >As a material can set further shader defines, which would be applied to all passes, the "vsexcludes" and "psexcludes" mechanism allows per-pass control to prevent them from being included. This is intended for eliminating the compilation of unnecessary shader variations, for example a shadow shader attempting to read a normal map.</p>
<p >The technique definition does not need to enumerate shaders used for different geometry types (non-skinned, skinned, instanced, billboard) and different per-vertex and per-pixel light combinations. Instead the engine will add certain hardcoded compilation defines for these. See <a class="el" href="_shaders.html">Shaders</a> for details.</p>
<p >The purposes of the different passes are:</p>
<ul>
<li>base: Renders ambient light, per-vertex lights and fog for an opaque object.</li>
<li>litbase: Renders the first per-pixel light, ambient light and fog for an opaque object. This is an optional pass for optimization.</li>
<li>light: Renders one per-pixel light's contribution additively for an opaque object.</li>
<li>alpha: Renders ambient light, per-vertex lights and fog for a transparent object.</li>
<li>litalpha: Renders one per-pixel light's contribution additively for a transparent object</li>
<li>postopaque: Custom rendering pass after opaque geometry. Can be used to render the skybox.</li>
<li>refract: Custom rendering pass after postopaque pass. Can sample the viewport texture from the environment texture unit to render refractive objects.</li>
<li>postalpha: Custom rendering pass after transparent geometry.</li>
<li>prepass: Light pre-pass only - renders normals, specular power and depth to the G-buffer.</li>
<li>material: Light pre-pass only - renders opaque geometry final color by combining ambient light, per-vertex lights and per-pixel light accumulation.</li>
<li>deferred: Deferred rendering only - renders ambient light and per-vertex lights to the output rendertarget, and diffuse albedo, normals, specular intensity + power and depth to the G-buffer.</li>
<li>depth: Renders linear depth to a rendertarget for post-processing effects.</li>
<li>shadow: Renders to a hardware shadow map (depth only) for shadow map generation.</li>
</ul>
<p >More custom passes can be defined and referred to in the <a class="el" href="_render_paths.html">render path definition</a>. For the built-in passes listed above, the lighting shader permutations to load (unlit, per-vertex or per-pixel) are recognized automatically, but for custom passes they need to be explicitly specified. The default is unlit.</p>
<p >The optional "litbase" pass reduces draw call count by combining ambient lighting with the first per-pixel light affecting an object. However, it has intentional limitations to not require too many shader permutations: there must be no vertex lights affecting the object, and the ambient lighting can not have a gradient. In case of excessive overdraw, it is possibly better not to define it, but instead allow the base pass (which is computationally very lightweight) to run first, initializing the Z buffer for later passes.</p>
<p >The refract pass requires pingponging the scene rendertarget to a texture, but this will not be performed if there is no refractive geometry to render, so there is no unnecessary cost to it.</p>
<h1><a class="anchor" id="Materials_RenderOrder"></a>
Render order caveats</h1>
<p >Render order works well when you know a material is going to render only a single pass, for example a deferred G-buffer pass. However when forward rendering and per-pixel lights are used, rendering of typical lit geometry can be split over the "base", "litbase" and "light" passes. If you use render order combined with depth test manipulation to force some object to render in front of others, the pass order may not be obvious. "Base" pass would be rendered first, but objects often don't use it, rather they render later as part of the forward light loop using the "litbase" pass. This may throw off the depth test manipulation and cause a different result than expected.</p>
<p >An easy fix is to simply disable the "litbase" optimization pass altogether, though this costs performance. This can be done globally from the forward renderpath (Bin/CoreData/RenderPaths/Forward.xml) by modifying the forwardlights command to read:</p>
<div class="fragment"><div class="line">&lt;command type=<span class="stringliteral">&quot;forwardlights&quot;</span> pass=<span class="stringliteral">&quot;light&quot;</span> uselitbase=<span class="stringliteral">&quot;false&quot;</span> /&gt;</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 22:07:56 for Urho3D by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
