<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urho3D: Scripting</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Urho3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Scripting </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >To enable AngelScript scripting support, the Script subsystem needs to be created and registered after initializing the <a class="el" href="class_urho3_d_1_1_engine.html" title="Urho3D engine. Creates the other subsystems.">Engine</a>. This is accomplished by the following code, seen eg. in Tools/Urho3DPlayer/Urho3DPlayer.cpp:</p>
<div class="fragment"><div class="line">context_-&gt;RegisterSubsystem(<span class="keyword">new</span> Script(context_));</div>
</div><!-- fragment --><p >There are three ways the AngelScript language can be interacted with in Urho3D:</p>
<h1><a class="anchor" id="Scripting_Immediate"></a>
Immediate execution</h1>
<p >Immediate execution takes one line of AngelScript, compiles it, and executes. This is not recommended for anything that needs high performance, but can be used for example to implement a developer console. Call the Script subsystem's Execute() function to use. For example:</p>
<div class="fragment"><div class="line">GetSubsystem&lt;Script&gt;()-&gt;Execute(<span class="stringliteral">&quot;Print(\&quot;Hello World!\&quot;);&quot;</span>);</div>
</div><!-- fragment --><p >It may be useful to be able to access a specific scene or a script file while executing immediate script code. These can be set on the Script subsystem by calling SetDefaultScene() and SetDefaultScriptFile().</p>
<h1><a class="anchor" id="Scripting_Procedural"></a>
Calling a function from a script file</h1>
<p >This requires a successfully loaded ScriptFile resource, whose Execute() function will be used. To identify the function to be called, its full declaration is needed. Parameters are passed in a VariantVector. For example:</p>
<div class="fragment"><div class="line">ScriptFile* file = GetSubsystem&lt;ResourceCache&gt;()-&gt;GetResource&lt;ScriptFile&gt;(<span class="stringliteral">&quot;Scripts/MyScript.as&quot;</span>);</div>
<div class="line"> </div>
<div class="line">VariantVector parameters;</div>
<div class="line">parameters.<a class="code hl_function" href="class_urho3_d_1_1_vector.html#a083b39861b996df82f811a9a4ebff109">Push</a>(Variant(100)); <span class="comment">// Add an int parameter</span></div>
<div class="line">file-&gt;Execute(<span class="stringliteral">&quot;void MyFunction(int)&quot;</span>, parameters); <span class="comment">// Execute</span></div>
<div class="ttc" id="aclass_urho3_d_1_1_vector_html_a083b39861b996df82f811a9a4ebff109"><div class="ttname"><a href="class_urho3_d_1_1_vector.html#a083b39861b996df82f811a9a4ebff109">Urho3D::Vector::Push</a></div><div class="ttdeci">void Push(const T &amp;value)</div><div class="ttdoc">Add an element at the end.</div><div class="ttdef"><b>Definition:</b> Vector.h:253</div></div>
</div><!-- fragment --><p >If the function being called has void return type and no parameters, its name can alternatively be given instead of the full declaration.</p>
<p >Execute() also has an overload which takes a function pointer instead of querying by declaration. Using a pointer is naturally faster than a query, but also more risky: in case the ScriptFile resource is unloaded or reloaded, any function pointers will be invalidated.</p>
<h1><a class="anchor" id="Scripting_Object"></a>
Instantiating a script object</h1>
<p >The component ScriptInstance can be used to instantiate a specific class from within a script file. After instantiation, the the script object can respond to scene updates, <a class="el" href="_events.html">events</a> and <a class="el" href="_serialization.html">serialization</a> much like a component written in C++ would do, if it has the appropriate methods implemented. For example:</p>
<div class="fragment"><div class="line">ScriptInstance* instance = node-&gt;CreateComponent&lt;ScriptInstance&gt;();</div>
<div class="line">instance-&gt;CreateObject(GetSubsystem&lt;ResourceCache&gt;()-&gt;GetResource&lt;ScriptFile&gt;(<span class="stringliteral">&quot;Scripts/MyClass.as&quot;</span>), <span class="stringliteral">&quot;MyClass&quot;</span>);</div>
</div><!-- fragment --><p >The class must implement the empty interface ScriptObject to make its base class statically known. This enables accessing any script object in the scene using ScriptInstance's GetScriptObject() function.</p>
<p >The following methods that implement the component behaviour will be checked for. None of them are required.</p>
<ul>
<li>void Start()</li>
<li>void Stop()</li>
<li>void DelayedStart()</li>
<li>void Update(float)</li>
<li>void PostUpdate(float)</li>
<li>void FixedUpdate(float)</li>
<li>void FixedPostUpdate(float)</li>
<li>void Save(Serializer&amp;)</li>
<li>void Load(Deserializer&amp;)</li>
<li>void WriteNetworkUpdate(Serializer&amp;)</li>
<li>void ReadNetworkUpdate(Deserializer&amp;)</li>
<li>void ApplyAttributes()</li>
<li>void TransformChanged()</li>
</ul>
<p >The update methods above correspond to the variable timestep scene update and post-update, and the fixed timestep physics world update and post-update. The application-wide update events are not handled by default.</p>
<p >The Start() and Stop() methods do not have direct counterparts in C++ components. Start() is called just after the script object has been created. Stop() is called just before the script object is destroyed. This happens when the ScriptInstance is destroyed, or if the script class is changed.</p>
<p >When a scene node hierarchy with script objects is instantiated (such as when loading a scene) any child nodes may not have been created yet when Start() is executed, and can thus not be relied upon for initialization. The DelayedStart() method can be used in this case instead: if defined, it is called immediately before any of the Update() calls.</p>
<p >TransformChanged() is called whenever the scene node transform changes and the node was not dirty before, similar to C++ components' OnMarkedDirty() function. The function should read the node's world transform (or rotation / position / scale) to reset the dirty status and ensure the next dirty notification is also sent.</p>
<p >Subscribing to <a class="el" href="_events.html">events</a> in script behaves differently depending on whether <a class="el" href="class_urho3_d_1_1_object.html#a7d9d061f4cf32f5fd5531e11a72834b6">SubscribeToEvent()</a> is called from a script object's method, or from a procedural script function. If called from an instantiated script object, the ScriptInstance becomes the event receiver on the C++ side, and calls the specified handler method when the event arrives. If called from a function, the ScriptFile will be the event receiver and the handler must be a free function in the same script file. The third case is if the event is subscribed to from a script object that does not belong to a ScriptInstance. In that case the ScriptFile will create a proxy C++ object on demand to be able to forward the event to the script object.</p>
<p >The script object's enabled state can be controlled through the SetEnabled() function. When disabled, the scripted update methods or event handlers will not be called. This can be used to reduce CPU load in a large or densely populated scene.</p>
<p >There are shortcut methods on the script side for creating and accessing a node's script object: node.CreateScriptObject() and node.GetScriptObject(). Alternatively, if the node has only one ScriptInstance, and a specific class is not needed, the node's scriptObject property can also be used. CreateScriptObject() takes the script file name (or alternatively, a ScriptFile object handle) and class name as parameters and creates a ScriptInstance component automatically, then creates the script object. For example:</p>
<div class="fragment"><div class="line">ScriptObject@ <span class="keywordtype">object</span> = node.CreateScriptObject(<span class="stringliteral">&quot;Scripts/MyClass.as&quot;</span>, <span class="stringliteral">&quot;MyClass&quot;</span>);</div>
</div><!-- fragment --><p >Note that these are not actual <a class="el" href="class_urho3_d_1_1_node.html" title="Scene node that may contain components and child nodes.">Node</a> member functions on the C++ side, as the Scene classes are not allowed to depend on scripting.</p>
<h1><a class="anchor" id="Scripting_ObjectSerialization"></a>
Script object serialization</h1>
<p >After instantiation, the script object's public member variables that can be converted into <a class="el" href="class_urho3_d_1_1_variant.html" title="Variable that supports a fixed set of types.">Variant</a>, and that don't begin with an underscore are automatically available as attributes of the ScriptInstance, and will be serialized. <a class="el" href="class_urho3_d_1_1_node.html" title="Scene node that may contain components and child nodes.">Node</a> and <a class="el" href="class_urho3_d_1_1_component.html" title="Base class for components. Components can be created to scene nodes.">Component</a> handles are also converted into nodeID and componentID attributes automatically. Note: this automatic attribute mechanism means that a ScriptInstance's attribute list changes dynamically depending on the class that has been instantiated.</p>
<p >If the script object contains more complex data structures, you can also serialize and deserialize into a binary buffer manually by implementing the Load() and Save() methods.</p>
<p >Network replication of the script object variables must be handled manually by implementing WriteNetworkUpdate() and ReadNetworkUpdate() methods, that also write and read a binary buffer. These methods should write/read all replicated of variables of the object. Additionally, the ScriptInstance must be marked for network replication by calling MarkNetworkUpdate() whenever the replicated data changes. Because this replication mechanism can not sync per variable, but always sends the whole binary buffer if even one bit of the data changes, also consider using the automatically replicated node user variables.</p>
<h1><a class="anchor" id="Script_DelayedCalls"></a>
Delayed method calls</h1>
<p >Delayed method calls can be used in script objects to implement time-delayed actions. Use the DelayedExecute() function in script object code to add a method to be executed later. The parameters are the delay in seconds, repeat flag, the full declaration of the function, and optionally parameters, which must be placed in a <a class="el" href="class_urho3_d_1_1_variant.html" title="Variable that supports a fixed set of types.">Variant</a> array. For example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test : ScriptObject</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> Start()</div>
<div class="line">    {</div>
<div class="line">        Array&lt;Variant&gt; parameters;</div>
<div class="line">        parameters.Push(Variant(100));</div>
<div class="line">        DelayedExecute(1.0, <span class="keyword">false</span>, <span class="stringliteral">&quot;void Trigger(int)&quot;</span>, parameters);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Trigger(<span class="keywordtype">int</span> parameter)</div>
<div class="line">    {</div>
<div class="line">        Print(<span class="stringliteral">&quot;Delayed function triggered with parameter &quot;</span> + parameter);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Delayed method calls can be removed by declaration using the ClearDelayedExecute() function. If an empty declaration (default) is given as parameter, all delayed calls are removed.</p>
<p >If the method being called has void return type and no parameters, its name can alternatively be given instead of the full declaration.</p>
<p >When a scene is saved/loaded, any pending delayed calls are also saved and restored.</p>
<h1><a class="anchor" id="Script_ScriptAPI"></a>
The script API</h1>
<p >Much of the Urho3D classes are exposed to scripts, however things that require low-level access or high performance (like direct low level rendering) are not. Also for scripting convenience some things have been changed from the C++ API:</p>
<ul>
<li>The template array and string classes are exposed as Array&lt;type&gt; and <a class="el" href="class_urho3_d_1_1_string.html" title="String class.">String</a>.</li>
<li>Public member variables are exposed without the underscore appended. For example x, y, z in <a class="el" href="class_urho3_d_1_1_vector3.html" title="Three-dimensional vector.">Vector3</a>.</li>
<li>Whenever only a single parameter is needed, setter and getter functions are replaced with properties. Such properties start with a lowercase letter. If an index parameter is needed, the property will be indexed. Indexed properties are in plural.</li>
<li>The element count property of arrays and other dynamic structures such as VariantMap and <a class="el" href="struct_urho3_d_1_1_resource_ref_list.html" title="List of typed resource references.">ResourceRefList</a> is called "length", though the corresponding C++ function is usually Size().</li>
<li>Subsystems exist as global properties: time, fileSystem, log, cache, network, input, ui, audio, engine, graphics, renderer, script, console, debugHud.</li>
<li>Additional global properties exist for accessing the script object's node, the scene and the scene-wide components: node, scene, octree, physicsWorld, debugRenderer. When an object method is not executing, these are null. An exception: when the default scene for immediate execution has been set by calling SetDefaultScene(), it is always available as "scene".</li>
<li>The currently executing script object's ScriptInstance component is available through the global property self.</li>
<li>The currently executing script file is available through the global property scriptFile.</li>
<li>The first script object created to a node is available as its scriptObject property.</li>
<li>Printing raw output to the log is simply called Print(). The rest of the logging functions are accessed by calling log.Debug(), log.Info(), log.Warning() and log.Error().</li>
<li>Functions that would take a <a class="el" href="class_urho3_d_1_1_string_hash.html" title="32-bit hash value for a string.">StringHash</a> parameter usually take a string instead. For example sending events, requesting resources and accessing components.</li>
<li>Most of StringUtils have been exposed as methods of the string class. For example String.ToBool().</li>
<li>Template functions for getting components or resources by type are not supported. Instead automatic type casts are performed as necessary.</li>
</ul>
<p >Check the automatically built <a class="el" href="_script_a_p_i.html">Scripting API</a> documentation for the exact function signatures. Note that the API documentation can be regenerated to the Urho3D log file by calling DumpAPI() function on the Script subsystem or by using <a class="el" href="_tools.html#Tools_ScriptCompiler">ScriptCompiler tool</a>.</p>
<h1><a class="anchor" id="Script_Bytecode"></a>
Precompiling scripts to bytecode</h1>
<p >Instead of compiling scripts from source on-the-fly during startup, they can also be precompiled to bytecode, then loaded. Use the <a class="el" href="_tools.html#Tools_ScriptCompiler">ScriptCompiler</a> utility for this.</p>
<p >The Script subsystem will automatically redirect script file resource requests (.as) to the compiled versions (.asc) if the .as file does not exist. Making a final build of a scripted application could therefore involve compiling all the scripts with ScriptCompiler, then deleting the original .as files from the build.</p>
<h1><a class="anchor" id="Scripting_Limitations"></a>
Limitations</h1>
<p >There are some complexities of the scripting system one has to watch out for:</p>
<ul>
<li>During the execution of the script object's constructor, the object is not yet associated with the ScriptInstance, and therefore subscribing to events, adding delayed method calls, or trying to access the node or scene will fail. The use of the constructor is best reserved for initializing member variables only.</li>
<li>When the resource request for a particular ScriptFile is initially made, the script file and the files it includes are compiled into an AngelScript script module. Each script module has its own class hierarchy that is not usable from other script modules, unless the classes are declared shared. See AngelScript documentation for more details.</li>
<li>If a ScriptFile resource is reloaded, all the script objects created from it will be destroyed, then recreated. They will lose any stored state as their constructors and Start() methods will be run again. This is rarely useful when running an actual game, but may be helpful during development.</li>
</ul>
<p >A global VariantMap, globalVars, can be accessed by all scripts to store shared data or to preserve data through script file reloads.</p>
<h1><a class="anchor" id="Scripting_Modifications"></a>
AngelScript modifications</h1>
<p >The following changes have been made to AngelScript in Urho3D:</p>
<ul>
<li>For performance reasons and to guarantee immediate removal of expired objects, AngelScript garbage collection has been disabled for script classes and the Array type. This has the downside that circular references will not be detected. Therefore, whenever you have object handles in your script, think of them as if they were C++ shared pointers and avoid creating circular references with them. For safety, consider using the value type WeakHandle, which is a WeakPtr&lt;RefCounted&gt; exposed to script and can be used to point to any engine object (but not to script objects.) An example of using WeakHandle:</li>
</ul>
<div class="fragment"><div class="line">WeakHandle rigidBodyWeak = node.CreateComponent(<span class="stringliteral">&quot;RigidBody&quot;</span>);</div>
<div class="line">RigidBody@ rigidBodyShared = rigidBodyWeak.Get(); <span class="comment">// Is null if expired</span></div>
</div><!-- fragment --><ul>
<li>Object handle assignment can be done without the @ symbol if the object in question does not support value assignment. All exposed Urho3D C++ classes that derive from <a class="el" href="class_urho3_d_1_1_ref_counted.html" title="Base class for intrusively reference-counted objects. These are noncopyable and non-assignable.">RefCounted</a> never support value assignment. For example, when assigning the <a class="el" href="class_urho3_d_1_1_model.html" title="3D model resource.">Model</a> and <a class="el" href="class_urho3_d_1_1_material.html" title="Describes how to render 3D geometries.">Material</a> of a <a class="el" href="class_urho3_d_1_1_static_model.html" title="Static model component.">StaticModel</a> component:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">object</span>.model = cache.GetResource(<span class="stringliteral">&quot;Model&quot;</span>, <span class="stringliteral">&quot;Models/Mushroom.mdl&quot;</span>);</div>
<div class="line"><span class="keywordtype">object</span>.material = cache.GetResource(<span class="stringliteral">&quot;Material&quot;</span>, <span class="stringliteral">&quot;Materials/Mushroom.xml&quot;</span>);</div>
</div><!-- fragment --><p >In unmodified AngelScript, this would have to be written as:</p>
<div class="fragment"><div class="line">@<span class="keywordtype">object</span>.model = cache.GetResource(<span class="stringliteral">&quot;Model&quot;</span>, <span class="stringliteral">&quot;Models/Mushroom.mdl&quot;</span>);</div>
<div class="line">@<span class="keywordtype">object</span>.material = cache.GetResource(<span class="stringliteral">&quot;Material&quot;</span>, <span class="stringliteral">&quot;Materials/Mushroom.xml&quot;</span>);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 9 2022 22:07:56 for Urho3D by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
