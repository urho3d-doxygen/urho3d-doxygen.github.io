<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urho3D: Shaders</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Urho3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Shaders </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Urho3D uses an ubershader-like approach: permutations of each shader will be built with different compilation defines, to produce eg. static or skinned, deferred or forward or shadowed/unshadowed rendering.</p>
<p >The building of these permutations happens on demand: technique and renderpath definition files both refer to shaders and the compilation defines to use with them. In addition the engine will add inbuilt defines related to geometry type and lighting. It is not generally possible to enumerate beforehand all the possible permutations that can be built out of a single shader.</p>
<p >On Direct3D compiled shader bytecode is saved to disk in a "Cache" subdirectory next to the shader source code, so that the possibly time-consuming compile can be skipped on the next time the shader permutation is needed. On OpenGL such mechanism is not available.</p>
<h1><a class="anchor" id="Shaders_InbuiltDefines"></a>
Inbuilt compilation defines</h1>
<p >When rendering scene objects, the engine expects certain shader permutations to exist for different geometry types and lighting conditions. These correspond to the following compilation defines:</p>
<p >Vertex shader:</p>
<ul>
<li>NUMVERTEXLIGHTS=1,2,3 or 4: number of vertex lights influencing the object</li>
<li>DIRLIGHT, SPOTLIGHT, POINTLIGHT: a per-pixel forward light is being used. Accompanied by the define PERPIXEL</li>
<li>SHADOW: the per-pixel forward light has shadowing</li>
<li>NORMALOFFSET: shadow receiver UV coordinates should be adjusted according to normals</li>
<li>SKINNED, INSTANCED, BILLBOARD: choosing the geometry type</li>
</ul>
<p >Pixel shader:</p>
<ul>
<li>DIRLIGHT, SPOTLIGHT, POINTLIGHT: a per-pixel forward light is being used. Accompanied by the define PERPIXEL</li>
<li>CUBEMASK: the point light has a cube map mask</li>
<li>SPEC: the per-pixel forward light has specular calculations</li>
<li>SHADOW: the per-pixel forward light has shadowing</li>
<li>SIMPLE_SHADOW, PCF_SHADOW, VSM_SHADOW: the shadow sampling quality that is to be used</li>
<li>SHADOWCMP: use manual shadow depth compare, Direct3D9 only for DF16 &amp; DF24 shadow map formats</li>
<li>HEIGHTFOG: object's zone has height fog mode</li>
</ul>
<h1><a class="anchor" id="Shaders_InbuiltUniforms"></a>
Inbuilt shader uniforms</h1>
<p >When objects or quad passes are being rendered, various engine inbuilt uniforms are set to assist with the rendering. Below is a partial list of the uniforms listed as HLSL data types. Look at the file Uniforms.glsl for the corresponding GLSL uniforms.</p>
<p >Vertex shader uniforms:</p>
<ul>
<li>float3 cAmbientStartColor: the start color value for a zone's ambient gradient</li>
<li>float3 cAmbientEndColor: the end color value for a zone's ambient gradient</li>
<li>float3 cCameraPos: camera's world position</li>
<li>float cNearClip: camera's near clip distance</li>
<li>float cFarClip: camera's far clip distance</li>
<li>float cDeltaTime: the timestep of the current frame</li>
<li>float4 cDepthMode: parameters for calculating a linear depth value between 0-1 to pass to the pixel shader in an interpolator.</li>
<li>float cElapsedTime: scene's elapsed time value. Can be used to implement animating materials</li>
<li>float4x3 cModel: the world transform matrix of the object being rendered</li>
<li>float4x3 cView: the camera's view matrix</li>
<li>float4x3 cViewInv: the inverse of the camera's view matrix (camera world transform)</li>
<li>float4x4 cViewProj: the camera's concatenated view and projection matrices</li>
<li>float4x3 cZone: zone's transform matrix; used for ambient gradient calculations</li>
</ul>
<p >Pixel shader uniforms:</p>
<ul>
<li>float3 cAmbientColor: ambient color for a zone with no ambient gradient</li>
<li>float3 cCameraPosPS: camera's world position</li>
<li>float4 cDepthReconstruct: parameters for reconstructing a linear depth value between 0-1 from a nonlinear hardware depth texture sample.</li>
<li>float cDeltaTimePS: the timestep of the current frame</li>
<li>float cElapsedTimePS: scene's elapsed time value</li>
<li>float3 cFogColor: the zone's fog color</li>
<li>float4 cFogParams: fog calculation parameters (see Batch.cpp and Fog.hlsl for the exact meaning)</li>
<li>float cNearClipPS: camera's near clip distance</li>
<li>float cFarClipPS: camera's far clip distance</li>
</ul>
<h1><a class="anchor" id="Shaders_Writing"></a>
Writing shaders</h1>
<p >Shaders must be written separately for HLSL (Direct3D) and GLSL (OpenGL). The built-in shaders try to implement the same functionality on both shader languages as closely as possible.</p>
<p >To get started with writing your own shaders, start with studying the most basic examples possible: the Basic, Shadow &amp; Unlit shaders. Note the shader include files which bring common functionality, for example Uniforms.hlsl, Samplers.hlsl &amp; Transform.hlsl for HLSL shaders.</p>
<p >Transforming the vertex (which hides the actual skinning, instancing or billboarding process) is a slight hack which uses a combination of macros and functions: it is safest to copy the following piece of code verbatim:</p>
<p >For HLSL: </p><div class="fragment"><div class="line">float4x3 modelMatrix = iModelMatrix;</div>
<div class="line">float3 worldPos = GetWorldPos(modelMatrix);</div>
<div class="line">oPos = GetClipPos(worldPos);</div>
</div><!-- fragment --><p >For GLSL: </p><div class="fragment"><div class="line">mat4 modelMatrix = iModelMatrix;</div>
<div class="line">vec3 worldPos = GetWorldPos(modelMatrix);</div>
<div class="line">gl_Position = GetClipPos(worldPos);</div>
</div><!-- fragment --><p >On both Direct3D and OpenGL the vertex and pixel shaders are written into the same file, and the entrypoint functions must be called VS() and PS(). In OpenGL mode one of these is transformed behind the scenes to the main() function required by GLSL. When compiling a vertex shader, the compilation define "COMPILEVS" is always present, and likewise "COMPILEPS" when compiling a pixel shader. These are heavily used in the shader include files to prevent constructs that are illegal for the "wrong" type of shader, and to reduce compilation time.</p>
<p >Vertex shader inputs need to be matched to vertex element semantics to render properly.. In HLSL semantics for inputs are defined in each shader with uppercase words (POSITION, NORMAL, TEXCOORD0 etc.) while in GLSL the default attributes are defined in Transform.glsl and are matched to the vertex element semantics with a case-insensitive string "contains" operation, with an optional number postfix to define the semantic index. For example iTexCoord is the first (semantic index 0) texture coordinate, and iTexCoord1 is the second (semantic index 1).</p>
<p >Uniforms must be prefixed in a certain way so that the engine understands them:</p>
<ul>
<li>c for uniform constants, for example cMatDiffColor. The c is stripped when referred to inside the engine, so it would be called "MatDiffColor" in eg. <a class="el" href="class_urho3_d_1_1_material.html#a27f2b7dd5a1ab57e0be7f9a30be657ed">SetShaderParameter()</a></li>
<li>s for texture samplers, for example sDiffMap.</li>
</ul>
<p >In GLSL shaders it is important that the samplers are assigned to the correct texture units. If you are using sampler names that are not predefined in the engine like sDiffMap, just make sure there is a number somewhere in the sampler's name and it will be interpreted as the texture unit. For example the terrain shader uses texture units 0-3 in the following way:</p>
<div class="fragment"><div class="line">uniform sampler2D sWeightMap0;</div>
<div class="line">uniform sampler2D sDetailMap1;</div>
<div class="line">uniform sampler2D sDetailMap2;</div>
<div class="line">uniform sampler2D sDetailMap3;</div>
</div><!-- fragment --><p >The maximum number of bones supported for hardware skinning depends on the graphics API and is relayed to the shader code in the MAXBONES compilation define. Typically the maximum is 64, but is reduced to 32 on the Raspberry PI, and increased to 128 on Direct3D 11 &amp; OpenGL 3. See also <a class="el" href="class_urho3_d_1_1_graphics.html#a13291417abeac01ed03e129d2a64f42e">GetMaxBones()</a>.</p>
<h1><a class="anchor" id="Shaders_API"></a>
API differences</h1>
<p >Direct3D9 and Direct3D11 share the same HLSL shader code, and likewise OpenGL 2, OpenGL 3, OpenGL ES 2 and WebGL share the same GLSL code. Macros and some conditional code are used to hide the API differences where possible.</p>
<p >When HLSL shaders are compiled for Direct3D11, the define D3D11 is present, and the following details need to be observed:</p>
<ul>
<li>Uniforms are organized into constant buffers. See the file Uniforms.hlsl for the built-in uniforms. See TerrainBlend.hlsl for an example of defining your own uniforms into the "custom" constant buffer slot.</li>
<li>Both textures and samplers are defined for each texture unit. The macros in Samplers.hlsl (Sample2D, SampleCube etc.) can be used to write code that works on both APIs. These take the texture unit name without the 's' prefix.</li>
<li>Vertex shader output position and pixel shader output color need to use the SV_POSITION and SV_TARGET semantics. The macros OUTPOSITION and OUTCOLOR0-3 can be used to select the correct semantic on both APIs. In the vertex shader, the output position should be specified last, as otherwise other output semantics may not function correctly. In general, it is necessary that the output semantics defined by the vertex shader are defined as pixel shader inputs in the same order. Otherwise the Direct3D shader compiler may assign the semantics wrong.</li>
<li>On Direct3D11 the clip plane coordinate must be calculated manually. This is indicated by the CLIPPLANE compilation define, which is added automatically by the <a class="el" href="class_urho3_d_1_1_graphics.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> class. See for example the LitSolid.hlsl shader.</li>
<li>Direct3D11 does not support luminance and luminance-alpha texture formats, but rather uses the R and RG channels. Therefore be prepared to perform swizzling in the texture reads as appropriate.</li>
<li>Direct3D11 will fail to render if the vertex shader refers to vertex elements that don't exist in the vertex buffers.</li>
</ul>
<p >For OpenGL, the define GL3 is present when GLSL shaders are being compiled for OpenGL 3+, the define GL_ES is present for OpenGL ES 2, WEBGL define is present for WebGL and RPI define is present for the Raspberry Pi. Observe the following differences:</p>
<ul>
<li>On OpenGL 3 GLSL version 150 will be used if the shader source code does not define the version. The texture sampling functions are different but are worked around with defines in the file Samplers.glsl. Likewise the file Transform.glsl contains macros to hide the differences in declaring vertex attributes, interpolators and fragment outputs.</li>
<li>On OpenGL 3 luminance, alpha and luminance-alpha texture formats are deprecated, and are replaced with R and RG formats. Therefore be prepared to perform swizzling in the texture reads as appropriate.</li>
<li>On OpenGL ES 2 precision qualifiers need to be used.</li>
</ul>
<h1><a class="anchor" id="Shaders_Precaching"></a>
Shader precaching</h1>
<p >The shader variations that are potentially used by a material technique in different lighting conditions and rendering passes are enumerated at material load time, but because of their large amount, they are not actually compiled or loaded from bytecode before being used in rendering. Especially on OpenGL the compiling of shaders just before rendering can cause hitches in the framerate. To avoid this, used shader combinations can be dumped out to an XML file, then preloaded. See <a class="el" href="class_urho3_d_1_1_graphics.html#a2664f84fe14e6cc7ccd750470427af32">BeginDumpShaders()</a>, <a class="el" href="class_urho3_d_1_1_graphics.html#a8bc0261c882ff0c3bc8fc5f2871eb54c">EndDumpShaders()</a> and <a class="el" href="class_urho3_d_1_1_graphics.html#ab7a91acbf613629e3b95f600b10e6c2a">PrecacheShaders()</a> in the <a class="el" href="class_urho3_d_1_1_graphics.html" title="Graphics subsystem. Manages the application window, rendering state and GPU resources.">Graphics</a> subsystem. The command line parameters -ds &lt;file&gt; can be used to instruct the <a class="el" href="class_urho3_d_1_1_engine.html" title="Urho3D engine. Creates the other subsystems.">Engine</a> to begin dumping shaders automatically on startup.</p>
<p >Note that the used shader variations will vary with graphics settings, for example shadow quality simple/PCF/VSM or instancing on/off. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 10 2022 04:54:52 for Urho3D by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
