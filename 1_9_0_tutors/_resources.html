<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Urho3D: Resources</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Urho3D
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Resources </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Resources include most things in Urho3D that are loaded from mass storage during initialization or runtime:</p>
<ul>
<li><a class="el" href="class_urho3_d_1_1_animation.html" title="Skeletal animation resource.">Animation</a></li>
<li><a class="el" href="class_urho3_d_1_1_image.html" title="Image resource.">Image</a></li>
<li><a class="el" href="class_urho3_d_1_1_model.html" title="3D model resource.">Model</a></li>
<li><a class="el" href="class_urho3_d_1_1_material.html" title="Describes how to render 3D geometries.">Material</a></li>
<li><a class="el" href="class_urho3_d_1_1_particle_effect.html" title="Particle effect definition.">ParticleEffect</a></li>
<li>ScriptFile</li>
<li><a class="el" href="class_urho3_d_1_1_shader.html" title="Shader resource consisting of several shader variations.">Shader</a></li>
<li><a class="el" href="class_urho3_d_1_1_sound.html" title="Sound resource.">Sound</a></li>
<li><a class="el" href="class_urho3_d_1_1_technique.html" title="Material technique. Consists of several passes.">Technique</a></li>
<li><a class="el" href="class_urho3_d_1_1_texture2_d.html" title="2D texture resource.">Texture2D</a></li>
<li><a class="el" href="class_urho3_d_1_1_texture2_d_array.html" title="2D texture array resource.">Texture2DArray</a></li>
<li><a class="el" href="class_urho3_d_1_1_texture3_d.html" title="3D texture resource.">Texture3D</a></li>
<li><a class="el" href="class_urho3_d_1_1_texture_cube.html" title="Cube texture resource.">TextureCube</a></li>
<li><a class="el" href="class_urho3_d_1_1_x_m_l_file.html" title="XML document resource.">XMLFile</a></li>
<li><a class="el" href="class_urho3_d_1_1_j_s_o_n_file.html" title="JSON document resource.">JSONFile</a></li>
</ul>
<p >They are managed and loaded by the <a class="el" href="class_urho3_d_1_1_resource_cache.html" title="Resource cache subsystem. Loads resources on demand and stores them for later access.">ResourceCache</a> subsystem. Like with all other <a class="el" href="_object_types.html">typed objects</a>, resource types are identified by 32-bit type name hashes (C++) or type names (script). An object factory must be registered for each resource type.</p>
<p >The resources themselves are identified by their file paths, relative to the registered resource directories or <a class="el" href="class_urho3_d_1_1_package_file.html">package files</a>. By default, the engine registers the resource directories Data and CoreData, or the packages Data.pak and CoreData.pak if they exist.</p>
<p >If loading a resource fails, an error will be logged and a null pointer is returned.</p>
<p >Typical C++ example of requesting a resource from the cache, in this case, a texture for a <a class="el" href="class_urho3_d_1_1_u_i.html" title="UI subsystem. Manages the graphical user interface.">UI</a> element. Note the use of a convenience template argument to specify the resource type, instead of using the type hash.</p>
<div class="fragment"><div class="line">healthBar-&gt;SetTexture(GetSubsystem&lt;ResourceCache&gt;()-&gt;GetResource&lt;Texture2D&gt;(<span class="stringliteral">&quot;Textures/HealthBarBorder.png&quot;</span>));</div>
</div><!-- fragment --><p >The same in script would look like this (note the use of a property instead of a setter function):</p>
<div class="fragment"><div class="line">healthBar.texture = cache.GetResource(<span class="stringliteral">&quot;Texture2D&quot;</span>, <span class="stringliteral">&quot;Textures/HealthBarBorder.png&quot;</span>);</div>
</div><!-- fragment --><p >Resources can also be created manually and stored to the resource cache as if they had been loaded from disk.</p>
<p >Memory budgets can be set per resource type: if resources consume more memory than allowed, the oldest resources will be removed from the cache if not in use anymore. By default the memory budgets are set to unlimited.</p>
<h1><a class="anchor" id="Resources_Background"></a>
Background loading of resources</h1>
<p >Normally, when requesting resources using <a class="el" href="class_urho3_d_1_1_resource_cache.html#aa1657db0fcf2a1578bcb4bd5a00146ca">GetResource()</a>, they are loaded immediately in the main thread, which may take several milliseconds for all the required steps (load file from disk, parse data, upload to GPU if necessary) and can therefore result in framerate drops.</p>
<p >If you know in advance what resources you need, you can request them to be loaded in a background thread by calling <a class="el" href="class_urho3_d_1_1_resource_cache.html#ac1ffaede8b37d132d053b092a7ddcf9c">BackgroundLoadResource()</a>. The event E_RESOURCEBACKGROUNDLOADED will be sent after the loading is complete; it will tell if the loading actually was a success or a failure. Depending on the resource, only a part of the loading process may be moved to a background thread, for example the finishing GPU upload step always needs to happen in the main thread. Note that if you call GetResource() for a resource that is queued for background loading, the main thread will stall until its loading is complete.</p>
<p >The asynchronous scene loading functionality <a class="el" href="class_urho3_d_1_1_scene.html#a37aeb39ae74b420d003a597adccac577">LoadAsync()</a>, <a class="el" href="class_urho3_d_1_1_scene.html#aa66ba16b03bd936a00b96e18da703947">LoadAsyncJSON()</a> and <a class="el" href="class_urho3_d_1_1_scene.html#a3cd90a6194226a9279aa127222401cf4">LoadAsyncXML()</a> have the option to background load the resources first before proceeding to load the scene content. It can also be used to only load the resources without modifying the scene, by specifying the LOAD_RESOURCES_ONLY mode. This allows to prepare a scene or object prefab file for fast instantiation.</p>
<p >Finally the maximum time (in milliseconds) spent each frame on finishing background loaded resources can be configured, see <a class="el" href="class_urho3_d_1_1_resource_cache.html#a06423b2b66b8f5537a8ae5f8fca30049">SetFinishBackgroundResourcesMs()</a>.</p>
<h1><a class="anchor" id="Resources_BackgroundImplementation"></a>
Implementing background loading</h1>
<p >When writing new resource types, the background loading mechanism requires implementing two functions: <a class="el" href="class_urho3_d_1_1_resource.html#a0300ecba56eb1a6b92863053c2a8c038">BeginLoad()</a> and <a class="el" href="class_urho3_d_1_1_resource.html#a3b2fab64e6c9f8b53cb579b1b6f89268">EndLoad()</a>. BeginLoad() is potentially called in a background thread and should do as much work (such as file I/O) as possible without violating the <a class="el" href="_multithreading.html">multithreading</a> rules. EndLoad() should perform the main thread finishing step, such as GPU upload. Either step can return false to indicate failure to load the resource.</p>
<p >If a resource depends on other resources, writing efficient threaded loading for it can be hard, as calling GetResource() is not allowed inside BeginLoad() when background loading. There are a few options: it is allowed to queue new background load requests by calling BackgroundLoadResource() within BeginLoad(), or if the needed resource does not need to be permanently stored in the cache and is safe to load outside the main thread (for example <a class="el" href="class_urho3_d_1_1_image.html" title="Image resource.">Image</a> or <a class="el" href="class_urho3_d_1_1_x_m_l_file.html" title="XML document resource.">XMLFile</a>, which do not possess any GPU-side data), <a class="el" href="class_urho3_d_1_1_resource_cache.html#a722ee073d9964dc6fae99041013d930b">GetTempResource()</a> can be called inside BeginLoad. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Dec 10 2022 04:54:52 for Urho3D by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
